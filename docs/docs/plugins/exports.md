# Exports

This plugin automatically generates and updates the `exports` field in your package.json file after each build. 

Bunup handles mapping all entry points to their corresponding output files, including ESM/CJS formats and type declarations. The exports field stays perfectly in sync with your build configuration always - no manual updates needed when you make any change to config.

## Usage

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts'],
	format: ['esm', 'cjs'],
	plugins: [exports()],
});
```

When using the exports plugin, your package.json will be automatically updated with the correct exports field each time you build. For example:

```json [package.json]
{
  "name": "my-package",
  "version": "1.0.0",
  "type": "module",
  "files": [
    "dist"
  ],
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    }
  }
}
```

## Options

### `customExports`

The `customExports` option allows you to specify additional export fields that will be preserved alongside the automatically generated exports. This is useful when you need custom export conditions or paths that aren't automatically generated by the build process.

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts'],
	format: ['esm', 'cjs'],
	plugins: [
		exports({
			customExports: (ctx) => ({
				'./package.json': './package.json',
			})
		})
	],
});
```

## Working with Multiple Entry Points

When your build configuration includes multiple entry points, the exports plugin will generate export fields for all of them. For example:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

export default defineConfig({
	entry: ['src/index.ts', 'src/plugins.ts', 'src/cli.ts'],
	format: ['esm', 'cjs'],
	plugins: [exports()],
});
```

This will generate exports for `.`, `./plugins`, and `./cli` in your package.json.

However, you might not want all entry points to be included in the exports field. For example, CLI entry points are typically not meant to be imported by other packages.

To control which entry points get included in the exports field, you can split your configuration into multiple build configs and only apply the exports plugin to the configs containing entries you want to expose:

```ts [bunup.config.ts]
import { defineConfig } from 'bunup';
import { exports } from 'bunup/plugins';

// Shared options for all configs
const sharedOptions = {
	format: ['esm', 'cjs'],
	outDir: 'dist',
	// other common options...
};

export default defineConfig([
	// Config for public API entries - with exports plugin
	{
		...sharedOptions,
		entry: ['src/index.ts', 'src/plugins.ts'],
		plugins: [exports()],
	},
	// Config for CLI entry - without exports plugin
	{
		...sharedOptions,
		entry: ['src/cli.ts'],
		// No exports plugin here
	},
]);
```

With this approach, only the entry points in the first config (`index.ts` and `plugins.ts`) will be included in the exports field, while `cli.ts` will be built but not exposed through exports.
