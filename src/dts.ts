// @ts-nocheck

import {execSync} from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

import {rollup} from 'rollup';
import dtsPlugin from 'rollup-plugin-dts';

/**
 * Generates a bundled DTS (TypeScript Declaration) content string for the specified entry file.
 * The output includes only exported types and their necessary dependencies (tree-shaken),
 * bundled into a single DTS file, instead of multiple files as generated by `tsc`.
 *
 * @param rootDir - The root directory of the project (absolute or relative path).
 * @param entry - The entry file path (absolute or relative, expected to be a .ts file).
 * @param tempDir - The directory where temporary files will be stored during processing.
 * @returns A promise that resolves to the bundled DTS content as a string.
 * @throws Error if the entry file is invalid, compilation fails, or bundling encounters issues.
 */
export async function generateDts(
    rootDir: string,
    entry: string,
    tempDir: string,
): Promise<string> {
    // Resolve absolute paths to ensure consistency
    const absoluteRootDir = path.resolve(rootDir);
    const absoluteEntry = path.resolve(entry);
    const absoluteTempDir = path.resolve(tempDir);

    // Validate inputs
    if (!fs.existsSync(absoluteRootDir)) {
        throw new Error(`Root directory does not exist: ${absoluteRootDir}`);
    }
    if (!fs.existsSync(absoluteEntry)) {
        throw new Error(`Entry file does not exist: ${absoluteEntry}`);
    }
    if (!absoluteEntry.endsWith('.ts')) {
        throw new Error(
            `Entry file must be a TypeScript file (.ts): ${absoluteEntry}`,
        );
    }
    if (!path.relative(absoluteRootDir, absoluteEntry).startsWith('..')) {
        // Check if entry is within rootDir (relative path should not start with '..')
    } else {
        throw new Error(`Entry file must be within rootDir: ${absoluteEntry}`);
    }

    // Set up temporary directory
    try {
        fs.mkdirSync(absoluteTempDir, {recursive: true});

        // Handle tsconfig.json: extend existing or create default
        const tsconfigPath = path.join(absoluteRootDir, 'tsconfig.json');
        let tempTsconfigContent: any;
        const dtsOutDir = './dts'; // Relative to tempDir

        const relativeRootDir = path.relative(absoluteTempDir, absoluteRootDir);
        tempTsconfigContent = {
            compilerOptions: {
                target: 'esnext',
                module: 'esnext',
                moduleResolution: 'node',
                strict: true,
                declaration: true,
                emitDeclarationOnly: true,
                skipLibCheck: true,
                outDir: dtsOutDir,
            },
            include: [`${relativeRootDir}/${entry}`],
        };

        const tempTsconfigPath = path.join(absoluteTempDir, 'tsconfig.json');
        fs.writeFileSync(
            tempTsconfigPath,
            JSON.stringify(tempTsconfigContent, null, 2),
        );

        // Run tsc to generate initial DTS files
        try {
            execSync(`tsc -p ${tempTsconfigPath}`, {stdio: 'inherit'});
        } catch (tscError) {
            throw new Error(
                `TypeScript compilation failed: ${tscError.message}`,
            );
        }

        // Calculate the DTS entry file path
        const relativePath = path.relative(absoluteRootDir, absoluteEntry);
        const dtsEntry = path
            .join(absoluteTempDir, dtsOutDir, relativePath)
            .replace(/\.ts$/, '.d.ts');
        if (!fs.existsSync(dtsEntry)) {
            throw new Error(`Generated DTS entry file not found: ${dtsEntry}`);
        }

        // Bundle DTS files using Rollup with tree-shaking
        const outputPath = path.join(absoluteTempDir, 'bundle.d.ts');
        let bundle;
        try {
            bundle = await rollup({
                input: dtsEntry,
                plugins: [dtsPlugin()],
                onwarn: (warning, warn) => {
                    // Suppress warnings or handle specific cases if needed
                    if (warning.code !== 'UNUSED_EXTERNAL_IMPORT') {
                        warn(warning);
                    }
                },
            });

            await bundle.write({
                file: outputPath,
                format: 'es',
            });
        } catch (rollupError) {
            throw new Error(`Rollup bundling failed: ${rollupError.message}`);
        } finally {
            if (bundle) {
                await bundle.close();
            }
        }

        // Read the bundled DTS content
        if (!fs.existsSync(outputPath)) {
            throw new Error(`Bundled DTS file not generated: ${outputPath}`);
        }
        const dtsContent = fs.readFileSync(outputPath, 'utf8');

        return dtsContent;
    } catch (error) {
        throw error instanceof Error
            ? error
            : new Error(`Unknown error: ${String(error)}`);
    } finally {
        // Clean up temporary directory and bundle
        if (fs.existsSync(absoluteTempDir)) {
            fs.rmSync(absoluteTempDir, {recursive: true, force: true});
        }
    }
}
